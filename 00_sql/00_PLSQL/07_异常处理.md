## 异常处理
PL/SQL 程序编译时的错误不是能被处理得异常，只有在运行时的异常能被处理。

## 抛出异常
- 通过 PL/SQL 运行时引擎
- 使用 RAISE 语句
```sql
DECLARE
inventory_too_low EXCEPTION;
--其他声明语句
BEGIN
.
.
IF order_rec.qty>inventory_rec.qty THEN
-- 当库存小于订单时抛出一个 inventory_too_low 异常
RAISE inventory_too_low;
END IF
.
.
EXCEPTION
WHEN inventory_too_low THEN
order_rec.staus:='backordered';
replenish_inventory(inventory_nbr=>
inventory_rec.sku,min_amount=>order_rec.qty-inventory_rec.qty);
END;
```

- 调用 RAISE_APPLICATION_ERROR 存储过程
```sql
RAISE_APPLICATION_ERROR(error_number, message, [keep_errors]);
-- error_number: 错误代码，必须在 -20000 到 -20999 之间
-- message: 自定义的错误描述信息（长度上限 2048 字节）。
-- keep_errors (可选): 布尔值。如果为 TRUE，新错误会放入错误堆栈；如果为 FALSE（默认），则替换之前的错误。

DECLARE
    v_balance NUMBER := 100;
    v_amount  NUMBER := 500; -- 想要转账500
BEGIN
    IF v_amount > v_balance THEN
        -- 触发自定义异常，不再继续执行
        RAISE_APPLICATION_ERROR(-20001, '转账失败：账户余额不足！当前余额为 ' || v_balance);
    END IF;
    
    -- 如果上面的 IF 成立，这行代码永远不会被执行
    UPDATE accounts SET balance = balance - v_amount WHERE id = 1;
END;
```

## 处理异常
当异常发生时，控制转到异常部分，ORACLE 查找当前异常相应的 WHEN..THEN 语句，捕捉异常，THEN 之后的代码被执行，如果错误陷阱代码只是退出相应的嵌套块，那么程序将继续执行内部块 END 后
面的语句。如果没有找到相应的异常陷阱，那么将执行 WHEN OTHERS。在异常部分 WHEN子串没有数量限制。

## 已命名异常
|异常名称|错误代码|触发场景|
|-|-|-|
|DUP_VAL_ON_INDEX|ORA-00001|主键冲突。|
|INVALID_CURSOR|ORA-01001|如：关闭一个未打开的游标。|
|NO_DATA_FOUND|ORA-01403|SELECT INTO 没查到任何数据。|
|TOO_MANY_ROWS|ORA-01422|SELECT INTO 返回了多于一行的数据。|
|ZERO_DIVIDE|ORA-01476|尝试用数字除以 0。|
|VALUE_ERROR|ORA-06502|算术、转换、截断或约束错误（如把超长字符串塞进短变量）。|
|INVALID_NUMBER|ORA-01722|尝试将非数字字符串转换为数字。|
